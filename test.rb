# Since all the tests are auto-generated by running run.rb with the 
# CREATE_SCENARIOS constant set to true, I thought it'd be easier
# to roll my own test framework. Which was true for generating the
# tests, not so much for running them. Port to minitest/rspec 
# eventually.

require 'pp'
require 'json'
require 'super_diff'
require 'pry' rescue nil
require 'socket'
require 'thread'

require_relative 'lib/manager'
require_relative 'lib/controller'

$failures = 0

SET_GEOMETRY_ITERATIONS = 1

class AssertEqFailedError < Exception ; end

def process(m,cmd)
  Controller.new(m).process(cmd)
end

# borrowed from https://github.com/mcmire/super_diff/issues/151
def assert_eq(actual, expected)
  if expected != actual
    diff = SuperDiff::Differs::Main.call(actual, expected)
    header = SuperDiff::Helpers.style do
      header "Diff:"
      newline
      newline
      border "┌ (Key) ──────────────────────────┐"
      newline
      border "│ "
      expected "‹-› in expected, not in actual"
      border "  │"
      newline
      border "│ "
      actual "‹+› in actual, not in expected"
      border "  │"
      newline
      border "│ "
      normal "‹ › in both expected and actual"
      border "  │"
      newline
      border "└─────────────────────────────────┘"
      newline
      newline
    end

    puts "#{header}#{diff}"
    raise AssertEqFailedError
  end
end

alias old_backtick `
def `(cmd)
  if $cmds.first&.first == cmd
    _input, output, status = $cmds.shift

    # sometimes we use $?.exitcode, but since $? is read-only, we 
    # 'mock' it by executing a shell command that just sets the 
    # exitcode
    old_backtick("return #{status || 0}")

    return output
  elsif $cmds.empty?
    puts "Shellout called but no mocks left!"
    pp $cmds
    puts "Define it like so:\n\n$cmds << [#{cmd.inspect}, \"<RESULT>\"]"
    raise 'shell-out mock not found'
  else
    puts "Shellout called but incorrect mock input found!"
    pp $cmds
    puts "Define a new mock like so:\n\n$cmds << [#{cmd.inspect}, \"<RESULT>\"]"
    puts "\n\nOr change the mock to:\n\n$cmds << [#{cmd.inspect}, #{$cmds.first.last.inspect}]"
    raise 'shell-out mock not found'
  end
end

def scenario
  begin
    $cmds = []
    yield
  rescue AssertEqFailedError => e
    $failures += 1
    trace = e.backtrace
    trace.shift
    puts trace.reverse
  end
end

at_exit do
  if $failures == 0
    puts "\n\ngreen!"
  else
    puts "\n\nred. #{$failures} failed assertions."
  end
end

puts "\n\n\n===\n\nrunning tests..."

Dir["scenarios/*.rb"].each {|n| require_relative n }
